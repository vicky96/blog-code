---
title: Angular的总结
date: 2020-04-20 16:28:15
tags: Framework
---

从2019年3月开始使用Angular，那时候刚进公司，项目刚刚开始，要求我们能够将之前JAVA Swing写的code转换成Angular前端页面，对于我来说可真是一个大大的挑战，Angular并没有接触过，Java更是一点也不懂。可是就是从这样一个完全不懂的状态，慢慢地学习，到最后能完全熟悉它，再到现在，都已经有一年的时间了。这个project也因为公司的原因突然终止，怎么说呢？很不舍，因为还没有把它完全做得很好，是一种遗憾，但是忙碌了这么久，总算有时间闲下来回顾和总结一下了，也是一个新的开始吧。

# 1.Angular的数据绑定原理：变更检测
  在Angular中所有操作(属性检查、dom操作)，都在视图上执行，每个视图与其组件相关联，它们都有一个状态，angular根据其值决定是否对视图及其所以子级运行更改检测
  
  比较： Vue的数据绑定原理：数据劫持以及发布订阅者模式（通过Object.defineProperty()劫持各个属性的setter和getter，从而 监控数据变化，在数据变化的时候发布消息给订阅者）
        React的数据绑定原理：虚拟dom，通过diff算法，对变化前后的虚拟dom进行比对，两个dom树只比较同一层级的节点，如果相同就直接删除，最后只剩下不同的节点，然后将这些不同的节点渲染到真实dom上

# 2.服务
  与特定视图无关并希望跨组件共享的数据或逻辑，服务类的定义通常紧跟在@injectable()装饰器后，该装饰器提供的元数据可以让服务作为依赖被注入到组件中

# 3.指令
  分为两种，结构型指令和属性型指令
  结构型：通过添加、移除或替换来修改布局，比如`*ngIf`、`*ngFor`
        `*ngIf`：是将元素从dom中物理删除，而不是隐藏，被删除的元素可以被当成垃圾回收起来，并释放内存。
              `*`是一个语法糖，angular把`*ngIf`属性翻译成`<ng-template>`元素并用它们来包裹宿主元素。
              每个宿主元素上只能放一个结构性指令，不能同时放`*ngFor`和`*ngIf`，因为结构性指令可能会对宿主元素及其子元素做很复杂的事情，如果有两个结构性指令，两者会冲突，不知道哪个优先。
              `*ngIf`是从dom中添加和移除元素，而不是显示和隐藏，这会提高性能，为什么？
              因为对于不可见的元素，angular仍然会检查变更，这样就会占用内存和运算资源。`*ngIf`还可以用来防范空指针错误，如果某个变量存在的时候才去获取值，这样可以防止变量不存在的时候报错
        `*ngFor`：给`*ngFor`设置trackBy，当要重新从服务器刷新已有列表的时候，虽然列表是之前显示过的，但是angular并不能识别，只能清除之前的列表，用新的dom元素创建列表，指定trackBy之后，往组件中添加一个方法，它会返回NgFor应该追踪的值，比如某个id，这样只有修改了id的内容才会触发元素替换

  属性型：修改现有元素的外观或行为，如ngModel、ngStyle

# 4.生命周期钩子
  `ngOnChanges()`：检测到数据绑定输入属性变化时响应，在 ngOnInit() 之前以及所绑定的输入属性的值发生变化时都会调用。每个发生变化的属性名都被映射到SimpleChange对象，给对象有属性的当前值（currentValue）和前一个值（previousValue）

  `ngOnInit()`：第一次显示数据绑定和设置指令或组件的输入属性之后，初始化指令或组件，可以在这里获取初始数据。它会在第一次ngOnChange完成之后被调用，ngOnChange会被调用很多次，但ngOnInit只会被调用一次

  `ngDoCheck`：检测，并在发生angular无法或不愿意自己检测的变化时调用，比如将鼠标移动其他input中

  `ngAfterContentInit`：把外部内容投影进组件的视图时调用。内容投影是指从组件外部导入html，并插入组件模版指定位置。

  `ngAfterContentChecked`：完成被投影组件内容的变更检测之后调用

  `ngAfterViewInit`：组件视图及其子组件视图初始化完成之后被调用

  `ngAfterViewChecked`：完成组件视图和子视图的变更检测后调用

  `ngOnDestory`：销毁组件前调用

# 5.组件传值
  父 => 子：a.@Input b.setter
  子 => 父：a.@output（子组件暴露一个EventEmitter属性，当事件发生时，子组件利用该属性emits（向上弹射）事件，父组件绑定到这个事件属性，并在事件发生时作出响应）
            b.建立本地变量读取子组件的属性和方法（#）
            c.@ViewChild：父组件的类访问子组件，把子组件作为ViewChild注入到父组件中
  父 <=> 子：服务
